from locust import HttpUser, task, between
import random
from datetime import datetime

class EcommerceUser(HttpUser):
    wait_time = between(1, 5)

    def on_start(self):
        self.created_unpaid_orders = []
        self.created_draft_orders = []
        # Fetch users
        try:
            response = self.client.get("/user-service/api/users")
            if response.status_code == 200:
                self.users = response.json().get("collection", [])
                self.user_ids = [u["userId"] for u in self.users]
            else:
                self.user_ids = [1]
        except:
            self.user_ids = [1]

        # Fetch products
        try:
            response = self.client.get("/product-service/api/products")
            if response.status_code == 200:
                self.products = response.json().get("collection", [])
                self.product_ids = [p["productId"] for p in self.products]
            else:
                self.product_ids = [1]
        except:
            self.product_ids = [1]
            
        # Fetch orders (for payments) - initial pool
        try:
            response = self.client.get("/order-service/api/orders")
            if response.status_code == 200:
                self.orders = response.json().get("collection", [])
                # We don't use these for payments to avoid "already paid" errors
                # self.order_ids = [o["orderId"] for o in self.orders]
            else:
                pass
        except:
            pass

    @task(3)
    def get_users(self):
        self.client.get("/user-service/api/users", name="/user-service/api/users")

    @task(3)
    def get_products(self):
        self.client.get("/product-service/api/products", name="/product-service/api/products")

    @task(2)
    def get_orders(self):
        self.client.get("/order-service/api/orders", name="/order-service/api/orders")

    @task(1)
    def get_payments(self):
        self.client.get("/payment-service/api/payments", name="/payment-service/api/payments")

    @task(1)
    def get_shippings(self):
        self.client.get("/shipping-service/api/shippings", name="/shipping-service/api/shippings")

    @task(1)
    def get_favourites(self):
        self.client.get("/favourite-service/api/favourites", name="/favourite-service/api/favourites")

    @task(2)
    def get_product_detail(self):
        if hasattr(self, 'product_ids') and self.product_ids:
            product_id = random.choice(self.product_ids)
            with self.client.get(f"/product-service/api/products/{product_id}", catch_response=True, name="/product-service/api/products/{id}") as response:
                if response.status_code == 404:
                    response.success() # Ignore 404s as products might be deleted by AdminUser
                elif response.status_code != 200:
                    response.failure(f"Failed with {response.status_code}")

    @task(2)
    def get_user_detail(self):
        if hasattr(self, 'user_ids') and self.user_ids:
            user_id = random.choice(self.user_ids)
            self.client.get(f"/user-service/api/users/{user_id}", name="/user-service/api/users/{id}")

    @task(2) # Increased weight to generate more orders for payments
    def create_order_simulation(self):
        # Simulate creating an order
        now = datetime.now()
        formatted_date = now.strftime("%d-%m-%Y__%H:%M:%S") + f":{now.microsecond:06d}"
        
        payload = {
            "orderDate": formatted_date,
            "orderDesc": f"Order generated by Locust {random.randint(1000, 9999)}",
            "orderFee": random.uniform(10.0, 100.0),
            "orderStatus": "CREATED",
            "cart": {
                "cartId": 1
            }
        }
        with self.client.post("/order-service/api/orders", json=payload, catch_response=True, name="/order-service/api/orders (create)") as response:
            if response.status_code == 200:
                try:
                    order_data = response.json()
                    order_id = order_data.get("orderId")
                    if order_id:
                        self.created_draft_orders.append(order_id)
                        response.success()
                    else:
                        response.failure("No orderId in response")
                except:
                    response.failure("Failed to parse response")
            elif response.status_code == 400:
                response.failure(f"Bad Request: {response.text}")
            else:
                response.failure(f"Failed with {response.status_code}")

    @task(1)
    def confirm_order_simulation(self):
        if not hasattr(self, 'created_draft_orders') or not self.created_draft_orders:
            return
            
        # Pop an order to confirm it
        order_id = self.created_draft_orders.pop(0)
        with self.client.patch(f"/order-service/api/orders/{order_id}/status", catch_response=True, name="/order-service/api/orders/{id}/status (update)") as response:
            if response.status_code == 200:
                self.created_unpaid_orders.append(order_id)
                response.success()
            else:
                # If failed, put it back? No, discard.
                response.failure(f"Failed to update status: {response.text}")

    @task(1)
    def create_payment_simulation(self):
        if not hasattr(self, 'created_unpaid_orders') or not self.created_unpaid_orders:
            return
            
        order_id = self.created_unpaid_orders.pop(0)
        payload = {
            "isPayed": True,
            "paymentStatus": "COMPLETED",
            "order": {
                "orderId": order_id
            }
        }
        with self.client.post("/payment-service/api/payments", json=payload, catch_response=True, name="/payment-service/api/payments (create)") as response:
            if response.status_code == 400:
                # If it fails with "already in payment process", we might have a race condition or logic issue
                # But since we are using fresh orders, it should be fine.
                # If it still fails, we log it.
                response.failure(f"Bad Request: {response.text}")
            elif response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed with {response.status_code}")

    @task(1)
    def add_favourite_simulation(self):
        if not hasattr(self, 'user_ids') or not self.user_ids:
            return
        
        # Fix: Create a product first to ensure it exists, instead of relying on random IDs
        # This avoids 404 errors when the database is fresh or products are deleted
        
        # 1. Create a temporary product
        import uuid
        category_id = 1 # Default category usually exists
        if hasattr(self, 'category_ids') and self.category_ids:
             category_id = random.choice(self.category_ids)
             
        prod_payload = {
            "productTitle": f"Fav Product {uuid.uuid4()}",
            "imageUrl": "https://example.com/fav.png",
            "sku": f"SKU-FAV-{random.randint(10000, 99999)}",
            "priceUnit": 50.0,
            "quantity": 10,
            "category": {
                "categoryId": category_id
            }
        }
        
        product_id = None
        with self.client.post("/product-service/api/products", json=prod_payload, catch_response=True, name="/product-service/api/products (create-for-fav)") as prod_resp:
            if prod_resp.status_code == 200:
                try:
                    product_id = prod_resp.json().get("productId")
                    prod_resp.success()
                except:
                    prod_resp.failure("Failed to parse product response")
            else:
                # If we can't create a product, try to use an existing one from the pool
                if hasattr(self, 'product_ids') and self.product_ids:
                    product_id = random.choice(self.product_ids)
                else:
                    return # Give up if no product available

        if not product_id:
            return

        # 2. Add to favourites
        user_id = random.choice(self.user_ids)
        now = datetime.now()
        formatted_date = now.strftime("%d-%m-%Y__%H:%M:%S") + f":{now.microsecond:06d}"
        
        payload = {
            "userId": user_id,
            "productId": product_id,
            "likeDate": formatted_date
        }
        
        with self.client.post("/favourite-service/api/favourites", json=payload, catch_response=True, name="/favourite-service/api/favourites (create)") as response:
            if response.status_code == 409:
                response.success() # Treat conflict as success (already exists)
            elif response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed with {response.status_code}: {response.text}")

    @task(1)
    def create_cart_simulation(self):
        if not hasattr(self, 'user_ids') or not self.user_ids:
            return
            
        user_id = random.choice(self.user_ids)
        payload = {
            "userId": user_id
        }
        self.client.post("/order-service/api/carts", json=payload, name="/order-service/api/carts (create)")

    @task(1)
    def create_user_simulation(self):
        fake_id = random.randint(10000, 99999)
        payload = {
            "firstName": f"Test{fake_id}",
            "lastName": f"User{fake_id}",
            "email": f"test{fake_id}@example.com",
            "phone": "1234567890",
            "imageUrl": "https://example.com/avatar.png",
            "credential": {
                "username": f"user{fake_id}",
                "password": "password123",
                "roleBasedAuthority": "ROLE_USER"
            }
        }
        with self.client.post("/user-service/api/users", json=payload, catch_response=True, name="/user-service/api/users (create)") as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed to create user: {response.status_code}")

    @task(1)
    def create_shipping_simulation(self):
        if not hasattr(self, 'created_draft_orders') or not self.created_draft_orders:
            return
        if not hasattr(self, 'product_ids') or not self.product_ids:
            return

        # Use pop to ensure we don't try to ship the same order twice
        order_id = self.created_draft_orders.pop(0)
        product_id = random.choice(self.product_ids)
        
        payload = {
            "orderedQuantity": 1,
            "productId": product_id,
            "orderId": order_id,
            "product": {
                "productId": product_id
            },
            "order": {
                "orderId": order_id
            }
        }
        
        with self.client.post("/shipping-service/api/shippings", json=payload, catch_response=True, name="/shipping-service/api/shippings (create)") as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed to create shipping: {response.status_code} - {response.text}")


    @task(1)
    def get_categories(self):
        self.client.get("/product-service/api/categories", name="/product-service/api/categories")

    @task(1)
    def get_carts(self):
        self.client.get("/order-service/api/carts", name="/order-service/api/carts")

    @task(1)
    def create_address_simulation(self):
        if not hasattr(self, 'user_ids') or not self.user_ids:
            return
            
        user_id = random.choice(self.user_ids)
        payload = {
            "fullAddress": f"{random.randint(1,999)} Test St",
            "postalCode": f"{random.randint(10000,99999)}",
            "city": "Test City",
            "user": {
                "userId": user_id
            }
        }
        with self.client.post("/user-service/api/address", json=payload, catch_response=True, name="/user-service/api/address (create)") as response:
            if response.status_code == 200:
                response.success()
            else:
                # print(f"Address Create Failed: {response.status_code} - {response.text}")
                response.failure(f"Failed with {response.status_code}")

    @task(1)
    def update_user_simulation(self):
        if not hasattr(self, 'users') or not self.users:
            return
            
        user = random.choice(self.users)
        # user_id = user.get("userId")
        
        # Clone and modify
        payload = user.copy()
        payload["phone"] = f"{random.randint(1000000000, 9999999999)}"
        
        with self.client.put("/user-service/api/users", json=payload, catch_response=True, name="/user-service/api/users (update)") as response:
            if response.status_code == 200:
                response.success()
            else:
                # print(f"User Update Failed: {response.status_code} - {response.text}")
                response.failure(f"Failed with {response.status_code}")


class AdminUser(HttpUser):
    wait_time = between(5, 10)
    weight = 1

    def on_start(self):
        self.created_products = []
        # Fetch categories
        try:
            response = self.client.get("/product-service/api/categories")
            if response.status_code == 200:
                self.categories = response.json().get("collection", [])
                self.category_ids = [c["categoryId"] for c in self.categories]
            else:
                self.category_ids = [1]
        except:
            self.category_ids = [1]

    @task(1)
    def create_category_simulation(self):
        import uuid
        payload = {
            "categoryTitle": f"Category {uuid.uuid4()}",
            "imageUrl": "https://example.com/cat.png",
            "subCategoriesDtos": [],
            "productDtos": []
        }
        with self.client.post("/product-service/api/categories", json=payload, catch_response=True, name="/product-service/api/categories (create)") as response:
            if response.status_code == 200:
                response.success()
            else:
                # print(f"Category Create Failed: {response.status_code} - {response.text}")
                response.failure(f"Failed to create category: {response.status_code}")

    @task(2)
    def create_product_simulation(self):
        if not hasattr(self, 'category_ids') or not self.category_ids:
            return

        category_id = random.choice(self.category_ids)
        payload = {
            "productTitle": f"New Product {random.randint(1000, 9999)}",
            "imageUrl": "https://example.com/prod.png",
            "sku": f"SKU-{random.randint(10000, 99999)}",
            "priceUnit": random.uniform(10.0, 500.0),
            "quantity": random.randint(1, 100),
            "category": {
                "categoryId": category_id
            }
        }
        
        with self.client.post("/product-service/api/products", json=payload, catch_response=True, name="/product-service/api/products (create)") as response:
            if response.status_code == 200:
                try:
                    prod = response.json()
                    self.created_products.append(prod.get("productId"))
                    response.success()
                except:
                    response.failure("Failed to parse product response")
            else:
                # print(f"Product Create Failed: {response.status_code} - {response.text}")
                response.failure(f"Failed to create product: {response.status_code}")

    @task(1)
    def update_product_simulation(self):
        if not self.created_products:
            return
            
        product_id = random.choice(self.created_products)
        
        with self.client.get(f"/product-service/api/products/{product_id}", catch_response=True, name="/product-service/api/products/{id}") as fetch_resp:
            if fetch_resp.status_code == 200:
                product = fetch_resp.json()
                product["priceUnit"] = product["priceUnit"] + 1.0
                
                self.client.put("/product-service/api/products", json=product, name="/product-service/api/products (update)")
            elif fetch_resp.status_code == 404:
                fetch_resp.success() # Ignore if already deleted
            else:
                fetch_resp.failure("Failed to fetch product for update")

    @task(1)
    def delete_product_simulation(self):
        if not self.created_products:
            return
            
        # Only delete products we created to avoid breaking other tests
        product_id = self.created_products.pop(0)
        with self.client.delete(f"/product-service/api/products/{product_id}", catch_response=True, name="/product-service/api/products/{id} (delete)") as response:
            if response.status_code == 200 or response.status_code == 204:
                response.success()
            elif response.status_code == 404:
                response.success() # Already deleted
            else:
                response.failure(f"Failed to delete product: {response.status_code}")


